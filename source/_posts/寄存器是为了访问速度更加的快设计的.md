%*X$c%Y$n 会把偏移X处的值赋给栈中偏移Y处指针指向的地址

`%x`、`%s`、`%n` 这些格式控制符，`printf` 会把它们当作指示去处理，而去读取栈上的其他内容  

# 寄存器是为了访问速度更加的快设计的

顺序是这样的

在 x86_64 架构（也就是 64位）的 System V 调用约定中，**前六个整数或指针类型参数**会依次通过寄存器传递，顺序如下：

1. **RDI**

2. **RSI**

3. **RDX**

4. **RCX**

5. **R8**

6. **R9**

   

而当处于系统调用（`syscall`）上下文时，调用约定略有不同，传递参数的顺序变为：

1. **RDI**
2. **RSI**
3. **RDX**
4. **R10** （替代用户空间中的 RCX）
5. **R8**
6. **R9**
   这是因为 `syscall` 指令会用 RCX 暂存返回指令地址，因而无法用于传参，因此内核使用 R10 来替代将原 RCX 的位置



还有通用寄存器

- 原始 x86 扩展寄存器：
- `rax`, `rbx`, `rcx`, `rdx`
- `rsi`, `rdi`, `rbp`（基址指针），`rsp`（栈顶指针）
- 新增的 64 位寄存器（x64 模式新增）：
- `r8`, `r9`, `r10`, `r11`, `r12`, `r13`, `r14`, `r15`



32位是rax eax

不同的功能

- `rax`: 存储系统调用号
- `rdi`: 存储文件名或文件描述符
- `rsi`: 存储缓冲区地址
- `rdx`: 存储字节数



orw时寄存器参数设置

read里的fd写3是因为程序执行的时候文件描述符是从3开始的，write里的1是标准输出到显示器



- `**RDI**` 寄存器 = **地址** of “/bin/sh” 字符串
- `**RSI**` = 0
- `**RDX**` = 0
- `**RAX**` = 系统调用号
- 然后执行 `**syscall**`

可以这么来理解：

选好了合适的函数名（某个特殊寄存器的特殊的值），你设定好了参数（其他寄存器的特殊的值），并call 这个函数（一个特殊的语句），就能够执行这个函数（产生作用）

```plain
rop寻找bin/sh

ROPgadget --binary retsyscall  --string '/bin/sh'
```

- 系统调用号，即 eax 应该为 0xb，因为是execve所以是0xb
- 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。
- 第二个参数，即 ecx 应该为 0
- 第三个参数，即 edx 应该为 0

payload实现

```plain
payload=b'a'*112+\      #112为实际栈溢出的偏移          
        p32(gadget_eax_ret_addr)+p32(0xb)+ \
        p32(gadget_edx_ecx_ebx_ret)+p32(0)+p32(0)+p32(bin_sh_addr)+ \
        p32(int_0x80_addr)
```

# 查看libc版本号

strings libc.so.6 | grep GLIBC_



修改替换libc文件

```python
patchelf --replace-needed libc.so.6 /home/yh3h636/桌面/libc.so.6 heap
```

libc和ld需要保持版本一致

设置ld文件。在文件夹里找到对应的ld版本修改名称，最后写链接的文件名

```python
patchelf --set-interpreter /home/yh3h636/桌面/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-linux-x86-64.so.2 --set-rpath /home/yh3h636/桌面/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ ./heap
```



## 怎么找到 one_gadget

比如：

onegadget获取偏移

```python
one_gadget libc-2.23.so
```

会列出一堆候选地址，大概长这样：

```plain
cpp


复制编辑
0x45216 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rsp+0x30 == NULL
```

这表示在 `libc` 偏移 `0x45216` 的位置有个 gadget，可以直接调用 `execve("/bin/sh", ...)`。

------

## 2. one_gadget 的“调用条件”（constraints）

one_gadget 通常会附带一些 **约束条件**，因为它利用了 `libc` 内部某些代码路径，这些路径对寄存器 / 内存有要求。



```plain
yaml


复制编辑
0x45216: execve("/bin/sh", rsp+0x30, environ)
constraints:
  rsp+0x30 == NULL
```

意思是：

- 调用这个 gadget 时，它会尝试执行 `execve("/bin/sh", rsp+0x30, environ)`
- 要求 `**rsp+0x30**` **指向的内存必须是 NULL**
  → 因为 `argv` 参数需要是 `NULL` 结尾的指针数组

如果条件不满足，`execve` 调用就会失败（可能直接崩溃）。

## 为什么会有这些条件？

因为 one_gadget 本质上不是“万能的 gadget”，而是 `libc` 内部某条执行路径（比如 `execve` 的某个错误分支、某个初始化流程），这条路径在调用时默认假定某些寄存器 / 内存布局已经满足条件。
所以用它时必须保证这些前置约束成立，否则就不能直接 getshell。

## 常见 gadget 类型

- **寄存器传参 gadget**

```plain
pop rdi ; ret     ; 控制 RDI
pop rsi ; ret     ; 控制 RSI
pop rdx ; ret     ; 控制 RDX
```

用来构造函数调用参数。

### **栈迁移 gadget**

1.

```plain
leave ; ret
```

可以调整栈指针，切换新的栈空间。

2.gadget: 

```plain
xchg esp, edi; ret
```

- `xchg esp, edi` = 交换 `esp` 和 `edi` 的值。
- 如果事先控制了 `edi = bss_addr`，那么交换之后：

- `esp` = `bss_addr`
- `edi` = 原本的 `esp`

- 紧接着执行 `ret` 指令：

- `ret` 会做的事情是：从 `[rsp]` 取出一个地址，跳转到那里执行，然后 `rsp += 8`（在 x64 下）。
- 由于此时 `rsp` 已经被我们换到 `bss_addr`，所以 `ret` 会把 BSS 上的数据当成“返回地址”，跳过去执行。
- 之后的 gadget、参数都从 BSS 上连续取 → 这就是 **栈迁移成功**。

- **任意指令 gadget**
  比如：

```plain
add rax, 1 ; ret
```

可以在构造链时对寄存器做运算。



把 `**top_chunk**` **的地址伪造为某个目标地址**，那么下一次 `malloc` 返回的 chunk 就会落在目标地址上。



https://mp.weixin.qq.com/s/pdv5MMUQ9ACpeCpyGnxb1Q



%p是将对应地址存的东西打印出来，而%n是将对应的地址作为指针索引，得到对应的内容。



systab 符号表



# canary

在ebp下面存放了一个随机值。不知道这个随机值，篡改的时候就会出错

%p 会把栈上的东西打印出来。当%p足够多的时候，就会把canary打印出来

%s 是打印地址存放的内容 

可以用它来泄露任意地址的内容